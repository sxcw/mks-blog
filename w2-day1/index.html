<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="MakerSqaure experience"><title>Day 6 Is the Beginning of Second Week | MKS Daily</title><link rel="stylesheet" type="text/css" href="/mks-blog//css/normalize.css"><link rel="stylesheet" type="text/css" href="/mks-blog//css/highlight.css"><link rel="stylesheet" type="text/css" href="/mks-blog//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Raleway|Droid+Serif|Lobster+Two:700"><link rel="Shortcut Icon" type="image/x-icon" href="/mks-blog/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/mks-blog/." class="title">MKS Daily</a><span class="subtitle">... <span class="special">once in a lifetime </span> bootcamp experience at MakerSquare</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/mks-blog/." class="sidebar-nav-item">Home</a><a href="/mks-blog/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Day 6 Is the Beginning of Second Week</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-06-06</div><div class="post-tags"><a class="post-tag-link" href="/mks-blog/tags/closure/">closure</a>/<a class="post-tag-link" href="/mks-blog/tags/during-bootcamp/">during-bootcamp</a>/<a class="post-tag-link" href="/mks-blog/tags/module/">module</a>/<a class="post-tag-link" href="/mks-blog/tags/scope/">scope</a></div></div></div><article><div class="container post"><p>Never fully understood the importance of Sunday until now… After an incredibly busy and intense week, Sunday came like a pouring rain after years of drought. Feeling refreshed and ready for the rest of the week! </p>
<h2 id="Scopes-Closures-Modules-Intro"><a href="#Scopes-Closures-Modules-Intro" class="headerlink" title="Scopes, Closures, Modules Intro"></a>Scopes, Closures, Modules Intro</h2><ul>
<li><code>var</code> creates a local variable; no <code>var</code> –&gt; changes variables</li>
<li><code>module</code>: is used to return an interface with hidden data</li>
<li>return a function, so we can return multiple objects that represent API, advantage: we can keep local variables, without polluting global namespace. </li>
<li>The module pattern is when you enclose a set of data and functionality in an outer scope that returns a “public API” for using the internal stuff.</li>
<li>Modules are all about encapsulating (aka hiding) details and behavior inside a scope, and exposing a more limited set of functionality as an “API” (in this case, just a collection of methods).</li>
<li>Encapsulation: the idea of the least privileged. Make things private and expose them if they need to be public</li>
<li>Modules as a code organization pattern reduce the chances of naming collisions. </li>
<li>Modules: 1) an outer wrapping function that gets executed. It doesn’t need to be an IIFE, but it has to be an outer function 2) must be one or more functions returned from that outer function call so the inner function(s) that have a closure over inner private scope. In other words, it returns at least one inner function with closure over the inner details</li>
</ul>
<ul>
<li><p>Class module pattern: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// revealing module pattern (Class module pattern)</span><br><span class="line">// stack &apos;class&apos; </span><br><span class="line"></span><br><span class="line">var stack = function()&#123;</span><br><span class="line">	var storage = [];</span><br><span class="line">	return &#123;</span><br><span class="line">		push: function</span><br><span class="line">		pop: function</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//maintain the integrity of stack, keeping variables private </span><br><span class="line">stack.push(10);</span><br><span class="line">stack.pop();</span><br><span class="line">stack.storage // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>Modified Module pattern</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo = (function()&#123;</span><br><span class="line">	var publicAPI = &#123;</span><br><span class="line">		bar: function()&#123;</span><br><span class="line">			publicAPI.baz();</span><br><span class="line">		&#125;,</span><br><span class="line">		baz: function() &#123;</span><br><span class="line">			console.log(&apos;baz&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	return publicAPI;</span><br><span class="line">&#125;)();</span><br><span class="line">foo.bar();</span><br></pre></td></tr></table></figure>
<ul>
<li>Browsify –&gt; get rid of global scope. In-browser JS has a global scope; in Node.js, every file has its own scope. </li>
</ul>
<h2 id="Lexical-Scope-Nested-Scope-Block-Scope"><a href="#Lexical-Scope-Nested-Scope-Block-Scope" class="headerlink" title="Lexical Scope, Nested Scope, Block Scope:"></a>Lexical Scope, Nested Scope, Block Scope:</h2><p>Below is my study notes, read more at <a href="https://github.com/getify/You-Dont-Know-JS" target="_blank">You Don’t Know JS</a>.</p>
<ul>
<li>Lexical scope is set when the function is created</li>
<li>Lexical scope rules are determined statically at compile-time. Anything that happens after compilation, during execution, is dynamic at run-time. This distinction is important because it helps us understand the difference between normal variables, which behave lexically, and the this binding, which behaves dynamically.</li>
<li>Declarations come in two forms: variable declarations and function declarations. The compiler will look for any of these declarations, and wherever it finds them, it will register them into the appropriate scopes.</li>
<li>A commonly used term “hoisting” refers to the process of finding declarations and assigning them to their owning scopes. Hoisting isn’t real, it’s just a metaphor for understanding the compiler and scopes. Hoisting describes moving (aka “hoisting”) all declarations to the top of their respective scopes. </li>
<li>The compiler handles all declarations before our code is executed. Hoisting is done in the compilation phase</li>
<li><code>var a = 2</code> : Compiler declares a variable (if not previously declared in the current scope), and second, when executing, Engine looks up the variable in Scope and assigns to it, if found.</li>
<li>LHS and RHS meaning “left/right-hand side of an assignment” doesn’t necessarily literally mean “left/right side of the = assignment operator”. There are several other ways that assignments happen, and so it’s better to conceptually think about it as: “who’s the target of the assignment (LHS)” and “who’s the source of the assignment (RHS)”.</li>
<li>Unfulfilled RHS references result in ReferenceErrors being thrown. Unfulfilled LHS references result in an automatic, implicitly-created global of that name, or a ReferenceError.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">    var b = a;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = foo( 2 );</span><br><span class="line"></span><br><span class="line">// Identify all the LHS look-ups (there are 3!).</span><br><span class="line">// c = .., a = 2 (implicit param assignment) and b = ..</span><br><span class="line">// Identify all the RHS look-ups (there are 4!).</span><br><span class="line">// foo(2.., = a;, a + .. and .. + b</span><br><span class="line">// https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch1.md#understanding-scope</span><br></pre></td></tr></table></figure>
<ul>
<li>The first traditional phase of a standard language compiler is called lexing (aka, tokenizing).</li>
<li>Scope look-up stops once it finds the first match. The same identifier name can be specified at multiple layers of nested scope, which is called “shadowing” (the inner identifier “shadows” the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and works its way outward/upward until the first match, and stops.</li>
<li>Leakage of global variable: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function baz(foo) &#123;</span><br><span class="line">	bam = &apos;create bam for me in global scope&apos;;</span><br><span class="line">&#125;</span><br><span class="line">// LHR of bam cannot be found on the global scope, so global scope will create it (trying to be helpful?)</span><br></pre></td></tr></table></figure>
<ul>
<li>Compilation phase: register all variables in their own scopes </li>
<li>In non-strict mode, reference error results in unfulfilled or undeclared RHS reference </li>
</ul>
<h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><ul>
<li>IIFEs are functions that are not declared but instead appear as expressions, and then are immediately invoked. This is a convenient way to create some scope inside another scope. ES6 lets us do similar things with { .. } blocks and let.</li>
</ul>
<h2 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h2><ul>
<li>The let keyword attaches the variable declaration to the scope of whatever block (commonly a { .. } pair) it’s contained in.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var foo = true;</span><br><span class="line"></span><br><span class="line">if (foo) &#123;</span><br><span class="line">    &#123; // &lt;-- explicit block</span><br><span class="line">        let bar = foo * 2;</span><br><span class="line">        bar = something( bar );</span><br><span class="line">        console.log( bar );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( bar ); // ReferenceError</span><br></pre></td></tr></table></figure>
<ul>
<li>We can create an arbitrary block for let to bind to by simply including a { .. } pair anywhere a statement is valid grammar. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   console.log( bar ); // ReferenceError!</span><br><span class="line">   let bar = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>declarations made with let will not hoist to the entire scope of the block they appear in. Such declarations will not observably “exist” in the block until the declaration statement.</li>
</ul>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><ul>
<li>Closure is how a function remembers and retains access to any outer lexical variables even when that function is executed in a different scope.</li>
<li>In other words: Closure is when a function remembers its lexical scope even when the outside function has finished executed and returned.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function setupEvents(elems) &#123;</span><br><span class="line">   var appName = &quot;Cool Stuff&quot;;</span><br><span class="line"></span><br><span class="line">   for (var i=0; i&lt;elems.length; i++) &#123;</span><br><span class="line">      (function(i)&#123;  // &lt;-- new `i` for each iteration</span><br><span class="line">         elems[i].addEventListener( &quot;click&quot;, function()&#123;</span><br><span class="line">            console.log( appName + &quot;: &quot; + i );</span><br><span class="line">         &#125; );</span><br><span class="line">      &#125;)(i);  // &lt;-- assigns current `i` value to per-iteration `i`</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// We want a scope for each iteration</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// more complex</span><br><span class="line">function setupEvents(elems) &#123;</span><br><span class="line">   var appName = &quot;Cool Stuff&quot;;</span><br><span class="line"></span><br><span class="line">   for (var i=0; i&lt;elems.length; i++) &#123;</span><br><span class="line">      let j = i;  // &lt;-- new `j` for each iteration with current `i` value</span><br><span class="line">      elems[i].addEventListener( &quot;click&quot;, function()&#123;</span><br><span class="line">         console.log( appName + &quot;: &quot; + j );</span><br><span class="line">      &#125; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// simpler</span><br><span class="line">function setupEvents(elems) &#123;</span><br><span class="line">   var appName = &quot;Cool Stuff&quot;;</span><br><span class="line"></span><br><span class="line">   for (let i=0; i&lt;elems.length; i++) &#123;  // &lt;-- new `i` for each iteration</span><br><span class="line">      elems[i].addEventListener( &quot;click&quot;, function()&#123;</span><br><span class="line">         console.log( appName + &quot;: &quot; + i );</span><br><span class="line">      &#125; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fn;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">   let j = i * 2;</span><br><span class="line">   if (j &lt; 7) &#123;</span><br><span class="line">      fn = function() &#123;</span><br><span class="line">         console.log( i, j );</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">// output: 5 6</span><br></pre></td></tr></table></figure>
<ul>
<li>Question: is it a closure?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = (function()&#123;</span><br><span class="line">  var o = &#123;bar:&apos;bar&apos;&#125;</span><br><span class="line">  return &#123;obj:o&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">console.log(foo.obj.bar);</span><br></pre></td></tr></table></figure>
<p>Answer: no, by definition, this is object reference, but there is no function keeping a reference to its scope</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li>If strict mode is in effect, the global object is not eligible for the default binding, so the this is instead set to undefined.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">    console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // TypeError: `this` is `undefined`</span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="https://github.com/sxcw" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2016 <a href="/mks-blog/." rel="nofollow">MKS Daily</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});</script></body></html>